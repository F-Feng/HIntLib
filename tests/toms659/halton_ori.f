      BLOCK DATA BDHALT
C
C       INITIALIZE LABELLED COMMON
C       "HALTON" FOR "INHALT" AND
C       "GOHALT"
C
      INTEGER S
      DOUBLE PRECISION E,PRIME(40)
C
      COMMON /HALTON/ E,PRIME,S
      SAVE /HALTON/
C
      DATA (PRIME(I),I=1,40)/2.0,3.0,5.0,7.0,11.0,
     +                       13.0,17.0,19.0,23.0,29.0,
     +                       31.0,37.0,41.0,43.0,47.0,
     +                       53.0,59.0,61.0,67.0,71.0,
     +                       73.0,79.0,83.0,89.0,97.0,
     +                       101.0,103.0,107.0,109.0,113.0,
     +                       127.0,131.0,137.0,139.0,149.0,
     +                       151.0,157.0,163.0,167.0,173.0/
C
      END
      SUBROUTINE INHALT(FLAG,DIMEN,ATMOST,TINY,QUASI)
C
C       THIS SUBROUTINE FIRST CHECKS WHETHER
C       THE USER-SUPPLIED DIMENSION "DIMEN" OF
C       THE QUASIRANDOM VECTORS IS ACCEPTABLE
C       (STRICTLY BETWEEN 0 AND 41): IF SO,
C       FLAG(1)=.TRUE.
C
C       THE USER SUPPLIES
C         ATMOST : AN UPPER BOUND ON
C                  THE NUMBERS OF VECTORS
C                  REQUIRED
C         TINY   : 2**(-B), WHERE B IS THE NUMBER
C                  OF BITS IN THE MANTISSAS OF
C                  DOUBLE-PRECISION CONSTANTS, OR
C                  SLIGHTLY HIGHER
C
C       IF FLAG(1) IS TRUE, THEN INHALT
C       CALCULATES A TOLERANCE PARAMETER
C       "E" TO MAKE THE PROGRAM WORK
C       CORRECTLY IN FINITE PRECISION
C       ARITHMETIC AND A PARAMETER "DELTA"
C       TO CHECK THAT "E" WORKS. IF ALL IS
C       WELL, FLAG(2) GETS SET TO TRUE.
C       IF FLAG(2) IS FALSE, THEN ATMOST
C       IS TOO BIG RELATIVE TO TINY.
C
C       IF FLAG(1) AND FLAG(2) ARE TRUE,
C       INHALT COMPUTES THE FIRST VECTOR
C       "QUASI". ALL SUBSEQUENT VECTORS
C       COME FROM GOHALT.
C
C       INPUTS: DIMEN,ATMOST,TINY,PRIME
C
C       GET PRIME FROM LABELLED COMMON
C       "HALTON" INITIALIZED WITH
C       BLOCK DATA "BDHALT"
C
C       OUTPUTS:
C         TO USER'S CALLING PROGRAM: FLAG,QUASI
C
C         TO GOHALT VIA LABELLED COMMON
C         "HALTON":
C            E     : TOLERANCE
C            PRIME : PRIME(K) IS THE RECIPROCAL
C                    OF THE K-TH PRIME NUMBER
C                    STARTING FROM TWO
C            S     : DIMENSION
C
      LOGICAL FLAG(2)
C
      INTEGER S,ATMOST,I,DIMEN
C
      DOUBLE PRECISION QUASI(40),PRIME(40),E,TINY,DELTA
C
      COMMON /HALTON/ E,PRIME,S
      SAVE /HALTON/
      EXTERNAL BDHALT
C
C       CHECK DIMEN
C
      S=DIMEN
      FLAG(1)=S.GT.1 .AND. S.LT.41
      IF(.NOT. FLAG(1)) RETURN
C
C       COMPUTE AND CHECK TOLERANCE
C
      E=0.9*(1.0/(ATMOST*PRIME(S))-10.0*TINY)
      DELTA=100*TINY*DBLE(ATMOST+1)*DLOG10(DBLE(ATMOST))
      FLAG(2)=DELTA .LE. 0.09*(E-10.0*TINY)
      IF(.NOT. FLAG(2)) RETURN
C
C       NOW COMPUTE FIRST VECTOR
C
      DO 10 I=1,S
          PRIME(I)=1.0/PRIME(I)
          QUASI(I)=PRIME(I)
   10   CONTINUE
C
      RETURN
      END
      SUBROUTINE GOHALT(QUASI)
C
C       THIS SUBROUTINE GENERATES A NEW
C       QUASIRANDOM VECTOR WITH EACH CALL
C
C       IT ADAPTS KEY IDEAS FROM HALTON AND
C       SMITH, COMM. ACM. 7 (1964), 701-702.
C
C       THE USER MUST CALL "INHALT" BEFORE
C       CALLING "GOHALT". AFTER CALLING "INHALT",
C       TEST FLAG(1) AND FLAG(2); IF EITHER
C       IS FALSE, DO NOT CALL "GOHALT".
C       READ THE COMMENTS AT THE BEGINNING OF
C       "INHALT" AND THEN THOSE BELOW.
C
C       INPUTS:
C        FROM USER'S CALLING PROGRAM:
C        QUASI - THE LAST QUASIRANDOM VECTOR
C        GENERATED
C
C        FROM LABELLED COMMON "HALTON":
C        E           TOLERANCE
C        PRIME       PRIME(K) IS NOW THE RECIPROCAL OF
C                    THE K-TH PRIME NUMBER STARTING FROM TWO
C        S           DIMENSION
C
C       OUTPUT:
C        QUASI - A NEW QUASIRANDOM VECTOR
C
      DOUBLE PRECISION QUASI(40),PRIME(40),E,T,
     +                 F,G,H
C
      INTEGER S,I
      COMMON /HALTON/ E,PRIME,S
      SAVE /HALTON/
      EXTERNAL BDHALT
C
C       GENERATE QUASI ONE COMPONENT AT A TIME
C       USING RADIX PRIME(K) FOR COMPONENT K
C
      DO 100 I=1,S
          T=PRIME(I)
          F=1.0-QUASI(I)
          G=1.0
          H=T
   50     IF(F-H .LT. E) THEN
C
C       THIS CHECKS WHETHER
C        Q+H>1-E
C
            G=H
            H=H*T
C
C       IF THIS IS THE (K-1)-ST TIME THIS
C       STATEMENT IS REACHED, CHECK WHETHER
C       QUASI(I)+R**(-K) > 1-E
C
            GOTO 50
C
C            THE BLOCK FROM STATEMENT 50 TO HERE
C            IS A "LOOP WHILE"
C
          ENDIF
C
C           FOR THE APPROPRIATE I (DEPENDING ON HOW
C           MANY TIMES THE LOOP WHILE BLOCK ABOVE
C           IS EXECUTED), NOW ADD H**(I+1)+H**(I)-1
C           TO THE OLD QUASI(I) TO GET THE NEXT QUASI(I)
C
          QUASI(I)=G+H-F
C
  100   CONTINUE
C
      RETURN
      END
      PROGRAM TESTH
C
C       THIS PROGRAM TESTS ACCURACY OF
C       NUMERICAL INTEGRATION USING "GOHALT"
C       AND INTEGRAND (2) OF DAVIS AND
C       RABINOWITZ, PAGE 406
C
C       IT USES A NONSTANDARD TIMING
C       ROUTINE "SECOND" AND A MACHINE-
C       DEPENDENT CONSTANT "TINY"
C
C       PARAMETER STATEMENT SPECIFIES INPUT
C       AND OUTPUT UNITS
C
      LOGICAL FLAG(2)
      INTEGER DIMEN,ATMOST,I,J,INPUT,OUTPUT
      REAL F,SUM,T1,T2
      DOUBLE PRECISION QUASI(40),TINY
      PARAMETER(INPUT=5,OUTPUT=6)
C
      READ(INPUT,*) DIMEN,ATMOST,TINY
      WRITE(OUTPUT,'(1H1)')
      WRITE(OUTPUT,*) 'TEST HALTON'
      WRITE(OUTPUT,*) 'DIMENSION = ',DIMEN
      WRITE(OUTPUT,*) 'ATMOST = ',ATMOST
      WRITE(OUTPUT,*) 'TINY = ',TINY
C
      CALL SECOND(T1)
      CALL INHALT(FLAG,DIMEN,ATMOST,TINY,QUASI)
      IF(.NOT. FLAG(1)) THEN
          WRITE(OUTPUT,*) 'DIMENSION = ',DIMEN
          WRITE(OUTPUT,*) 'DIMEN IS NOT OK'
          STOP
        ENDIF
      IF(.NOT. FLAG(2)) THEN
          WRITE(OUTPUT,*) 'ATMOST = ',ATMOST
          WRITE(OUTPUT,*) 'ATMOST IS NOT OK'
          STOP
        ENDIF
      WRITE(OUTPUT,*) 'START TIME = ',T1
      WRITE(OUTPUT,*) 'I = ITERATION NUMBER'
      WRITE(OUTPUT,*) 'EI = ESTIMATE OF INTEGRAL'
      WRITE(OUTPUT,'(1H )')
C
      SUM=0.0
      DO 100 I=1,ATMOST
          CALL GOHALT(QUASI)
          F=1.0
          DO 50 J=1,DIMEN
              F=F*ABS(4.0*QUASI(J)-2.0)
   50       CONTINUE
          SUM=SUM+F
          IF(MOD(I,500).EQ.0) THEN
              WRITE(OUTPUT,*) 'I = ',I
              WRITE(OUTPUT,*) 'EI = ',SUM/I
              CALL SECOND(T2)
              WRITE(OUTPUT,*) 'TIMEI = ',T2-T1
              WRITE(OUTPUT,'(1H )')
            ENDIF
 100    CONTINUE
C
      STOP
      END
