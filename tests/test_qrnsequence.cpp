/*
 *  HIntLib  -  Library for High-dimensional Numerical Integration 
 *
 *  Copyright (C) 2002  Rudolf Schürer <rudolf.schuerer@sbg.ac.at>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 */

/**
 *  Test QRN Sequence
 *
 *  Creates and dispalys points from a QRN Sequence
 */

#include <iostream>
#include <iomanip>
#include <memory>

#include <HIntLib/qrnsequence.h>
#include <HIntLib/exception.h>
#include <HIntLib/hypercube.h>
#include <HIntLib/statistic.h>
#include <HIntLib/make.h>

#include "test.h"

using std::cerr;
using std::cout;
using std::setw;
using std::ostream;

using L::real;
using L::Index;
using L::QRNSequence;

/*
 *  Process command line options
 */

const char* options = "p:d:";

unsigned PRECISION = 6;
unsigned DIM = 5;

bool opt (int c, const char* s)
{
   switch (c)
   {
   case 'p':
      PRECISION = atoi (s);
      if (PRECISION >= 1 && PRECISION <= 20)  return true;
      break;
   case 'd':
      DIM = atoi (s);
      if (DIM >= 1 && DIM <= 100000)  return true;
      break;
   }

   return false;
}

void usage()
{
   cerr <<
      "Usage: test_qrnsequence [OPTION]... seq SEQ      [[START] END]\n"
      "       test_qrnsequence [OPTION]... net NET SIZE [[START] END]\n\n"
      "Prints the point set generated by a QRN sequences.\n\n"
      << option_msg <<
      "  -d n   Dimension of the sequence (default = 5)\n"
      "  -p n   Number of digits to be displayed (default = 6)\n"
      "  SEQ    Number of the sequence\n"
      "  NET    Number of the net\n"
      "  SIZE   Maximum size of the net\n"
      "  START  Index of the first point (default = 0)\n"
      "  END    Index of one past the last point\n"
      "            (default = 32 for sequences, full size for nets)\n\n";

   exit (1);
}

void test (int argc, char** argv)
{
   // Determins which sequence should be generated

   enum Type {SEQUENCE, NET} type = NET;

   if (argc < 2)  usage();
        if (strcmp (argv [0], "seq") == 0)  type = SEQUENCE;
   else if (strcmp (argv [0], "net") == 0)  type = NET;
   else usage();

   const unsigned SEQ = atoi (argv [1]);

   int next = 2;
   unsigned S;
   Index SIZE = 0;
   QRNSequence* p;

   try
   {
      // Create QRNSequence number SEQ

      if (type == NET)
      {
         if (argc < 3)  usage();
         S = atoi (argv [2]);
         next = 3;

         p = L::Make::qrnNet (SEQ, L::Hypercube (DIM), S);

         SIZE = p->getOptimalNumber (S);
      }
      else
      {
         p = L::Make::qrnSequence (SEQ, L::Hypercube (DIM));
      }

      std::auto_ptr<QRNSequence> gen (p);

      // Determine which part of the sequence should be displayd

      Index START = 0;
      Index END   = (type == SEQUENCE) ? 32 : SIZE;

      if (argc - next > 2)  usage();

      if (argc - next == 2)
      {
         START = atoi (argv[2]);
         END   = atoi (argv[3]);
      }
      else if (argc - next == 1)
      {
         END   = atoi (argv[2]);
      }

      // Print Introduction

      NORMAL
      {
         if (type == SEQUENCE)
         {
            cout << "\nPrinting QRNSequence '"
                 << L::Make::getQrnSequenceName (SEQ) << "' "
                    "in dimension s = " << DIM << ".\n\n";
         }
         else
         {
            cout << "\nPrinting QRNNet '"
                 << L::Make::getQrnNetName (SEQ) << "' "
                    "in dimension s = " << DIM
                 << " with " << SIZE << " points.\n\n";
         }
      }

      // Print elements from sequence

      cout << std::setprecision (PRECISION);

      SILENT
      {
         cout.setf (ostream::left, ostream::adjustfield);
         cout.setf (ostream::fixed, ostream::floatfield);
      }

      L::Array<real> x (DIM);
      L::Array<L::Statistic<> > stat (DIM);

      gen->first (x, START);

      while (gen->getIndex() < END)
      {
         Index i = gen->getIndex();

         NORMAL
         {
            cout.setf (ostream::right, ostream::adjustfield);
            cout << setw (4) << i << ' '
                 << ((i+1 == gen->getOptimalNumber(i+1)) ? '_' : ' ') << ' ';
            cout.setf (ostream::left, ostream::adjustfield);
         }

         for (unsigned dim = 0; dim < DIM; ++dim)
         {
            cout << setw (PRECISION + 4) << x[dim];

            stat[dim] << x[dim];
         }

         cout << '\n';

         gen->next (x);
      }

      // Print footer

      NORMAL
      {
         cout << "\n Avg:  ";

         for (unsigned dim = 0; dim < DIM; ++dim)
         {
            cout << setw(PRECISION + 4) << stat[dim].getMean();
         }

         cout << '\n';
      }
   }
   catch (L::Make::QRNSequenceDoesNotExist &e)
   {
      cerr << '\n'
           << ((type == SEQUENCE) ? "QRN-sequence" : "QRN-net")
           << "number " << e.getNumber() << " does not exist!\n\n";
      
      NORMAL
      {
         cout << "Valid QRNSequence numbers are:\n";

         for (unsigned i = 0; i < 10000; ++i)
         {
            try
            {
               const char* s = (type == SEQUENCE)
                  ? L::Make::getQrnSequenceName (i)
                  : L::Make::getQrnNetName (i);
   
               cout << setw (8) << i << "  " << s << '\n';
            }
            catch (L::Make::QRNSequenceDoesNotExist &) {}
         }
      }
      exit (1);
   }
}


